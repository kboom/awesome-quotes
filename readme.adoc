:toc: macro

:building_microservices: footnote:1[Quote from: Building Microservices, 2nd Edition, by Sam Newman]

= Golden software engineering quotes

Golden software engineering quotes which best reveal most important axioms of modern software.
Most of them can be found online. If you have a tough decision to make, try to go through this list to see if you can gather any clues about what decision might be the better one.

---

toc::[]

---

== Productivity

=== If you pile up enough tomorrows then you’ll be left with nothing but a bunch of empty yesterdays.

== Management

=== Incentives are counterproductive.

There are three effective motivators:

Autonomy::
Urge to direct your own life.

Mastery::
The desire to become better and better at something that matters.

Purpose::
The need to do something what we do in service to something larger to ourselves.

=== Most meetings should be optional but inclusive.

Mandatory meetings are by definition a contradiction of autonomy.
If authority is required to keep people at the meeting, then the meeting is not worthy people's time.
Make people interested, mainly by combining the three motivators - autonomy, mastery and purpose.

=== In a hierarchy every employee tends to rise to his level of incompetence.

=== Above all, resist the urge to manage.

=== Traditional managers worry about how to get things done, whereas great managers worry about what things get done and trust their team to figure out how to do it.

=== Hope is not a strategy.

Most team leaders grit their teeth, avert their eyes, and just hope that the low performer either magically improves or
just goes away. Yet it is extremely rare that this person does either. While the leader is hoping and the low performer
isn’t improving (or leaving), high performers on the team waste valuable time pulling the low performer along, and team
morale leaks away into the ether. You can be sure that the team knows the low performer is there even if you’re ignoring
them—in fact, the team is acutely aware of who the low performers are, because they have to carry them. Ignoring low
performers is not only a way to keep new high performers from joining your team, but it’s also a way to encourage
existing high performers to leave.

=== A people hire other A people; B people hire C people.

== Testing

=== Strive for Unchanging Tests.

The ideal test is unchanging: after it’s written, it never needs to change unless the requirements of the system under
test change.

* Test the public API and not the implementation details.
* Test the system state and not the interactions.
** Do not check if something gets called or not.
** Avoid mocking and prefer using real objects.

=== DAMP is superior to DRY.

Descriptive And Meaningful Phrases. A little bit of duplication is OK in tests so long as that duplication makes the
test simpler and clearer.

== Architecture

=== Everything in software architecture is a trade-off.

=== A structure is stable if cohesion is strong and coupling is low.

Cohesion applies to the relationship between things inside a boundary, whereas coupling describes the relationship between things across a boundary. There is no absolute best way to organize our code; coupling and cohesion are just one way to articulate the various trade-offs we make around where we group code, and why. All we can strive to do is to find the right balance between these two ideas, one that makes the most sense for your given context and the problems you are currently facing.{building_microservices}

==== Hide information which is irrelevant to external domains and services.

Share only what you absolutely have to, and send only the absolute minimum amount of data that you need.
A loosely coupled service knows as little as it needs to about the services with which it collaborates.
The connections between modules are the assumptions which the modules make about each other.

==== The code that changes together, stays together.

Coupling, though, comes in many forms, and I’ve seen a number of misunderstandings about the nature of coupling as it pertains to a service-based architecture.

=== Why is more important than how.

We tend to be drawn to exciting problems to solve without thinking if these really are problems worth solving.
Remember that time cannot expand and by investing in once place we're loosing in other, potentially more beneficial.

=== Scale comes from simplicity.

=== Successful abstractions are the simple ones.

Simple ideas are actually much more likely to be used because of adoption and being able to grow. Simple ideas must fit inside your brain. __MapReduce__ can be one example.

=== Coupling comes in many forms.

* *Domain coupling* describes a situation in which one microservice needs to interact with another microservice, because the first microservice needs to make use of the functionality that the other microservice provides. This type of interaction is largely unavoidable and is considered to be a loose form of coupling, but make sure to hide as much information as possible.
* *Temporal coupling* is a situation in which concepts are bundled together purely because they happen at the same time, that is when one microservice needs another microservice to do something at the same time for the operation to complete. Both services need to be up and available to communicate with each other at the same time for the operation to complete. Temporal coupling isn’t always bad; it’s just something to be aware of. As you have more microservices, with more complex interactions between them, the challenges of temporal coupling can increase to such a point that it becomes more difficult to scale your system and keep it working. One of the ways to avoid temporal coupling is to use some form of asynchronous communication, such as a message broker.{building_microservices}
* *Pass-through coupling* describes a situation in which one microservice passes data to another microservice purely because the data is needed by some other microservice further downstream. In many ways it’s one of the most problematic forms of implementation coupling, as it implies not only that the caller knows not just that the microservice it is invoking calls yet another microservice, but also that it potentially needs to know how that one-step-removed microservice works. The major issue with pass-through coupling is that a change to the required data downstream can cause a more significant upstream change.
* *Common coupling* occurs when two or more microservices make use of a common set of data. A simple and common example of this form of coupling would be multiple microservices making use of the same shared database, but it could also manifest itself in the use of shared memory or a shared filesystem. The main issue with common coupling is that changes to the structure of the data can impact multiple microservices at once. Sources of common coupling are also potential sources of resource contention and central points of failure.
* *Content coupling* describes a situation in which an upstream service reaches into the internals of a downstream service and changes its internal state. The most common manifestation of this is an external service accessing another microservice’s database and changing it directly. With common coupling, you understand that you are making use of a shared, external dependency. You know it’s not under your control. With content coupling, the lines of ownership become less clear, and it becomes more difficult for developers to change a system.



=== The data always outlives code.

=== Design your data model for the sake of your domain model, not your domain model for the sake of your data model.

=== Constraints enforce elegant design and can give rise to its better properties. The more constraints the more one frees one's self.

=== Having a language that allows you to do anything is not an advantage, it is a liability. You have to find the heart and essence and build on top of that.

=== Software is built not like architecture.
In architecture you can or build buildings from smaller buildings. In software you create software from smaller software and there are no boundaries. This is why the simple ideas are so important - they can bubble up to the top level of the design. Best example might be map reduce. Building architecture has natural scale - a human being. It is designed for a human scale and this is why it impresses us. For software there is no such thing. A human brain may be a limit - can we fit the idea in our brain? Having too much stuff in your brains slows you down and makes you prone to errors.

=== We are far to easily impressed and imprisoned by the concept of size.
Smallness has virtues we should insist on. We should not assume growth without bounds. Economy of scale so much engrained in us but does not apply in software. It does not get cheaper with size.
* How much work does the developers do on things accidental as opposed to essential? Look at how many people work on this code, it has to be special!

=== Avoid cargo-cult programming.

In software there is a diseconomy of scale the more people you have the more problems you will get - cargo cult programming.

=== All code is technical debt, some just have more interest rate.

=== Dead code may be not so dead at some point and be zombie causing trouble.

=== Architecture is like garden - you can grow things but you have to cut other things down.

=== The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go wrong goes wrong it usually turns out to be impossible to get at or repair.

=== Software becomes an artifact of group intelligence. A design must be organized according to the structure of communication within the organization like convey law states.

=== Data systems amplify the data they hold whereas microservices conceal the data they hold.

=== Beware the cycle of data inadequacy, this is why a real data system is needed.

image::https://www.confluent.io/wp-content/uploads/image06-1024x681.png[The Cycle of Data Inadequacy]

== References

* link:https://learning.oreilly.com/library/view/software-engineering-at/9781492082781/ch12.html#unit_testing[Software Engineering at Google]
